./regsim -m 100000 -l scheme rms/interpreterInit.rms rms/interpreterRun.rms

(() () ((test (op =) (reg init) (const 0)) (branch (label read-eval-print-loop)) (assign env (op get-global-environment)) (assign val (op make-compiled-procedure) (label apply) (reg env)) (perform (op define-variable!) (const apply) (reg val) (reg env)) (assign val (op make-compiled-procedure) (label eval) (reg env)) (perform (op define-variable!) (const eval) (reg val) (reg env)) (assign val (op make-compiled-procedure) (label load) (reg env)) (perform (op define-variable!) (const load) (reg val) (reg env)) (assign val (op make-compiled-procedure) (label call-with-current-continuation) (reg env)) (perform (op define-variable!) (const call-with-current-continuation) (reg val) (reg env)) (perform (op define-variable!) (const call/cc) (reg val) (reg env)) (assign exp (op list) (const load) (const "init.scm")) (assign continue (label end-of-interpreter)) (goto (label eval-dispatch)) read-eval-print-loop (perform (op initialize-stack)) (perform (op newline)) (perform (op display) (const ";;; input:")) (perform (op newline)) (perform (op newline)) (assign exp (op read)) (perform (op newline)) (test (op eof-object?) (reg exp)) (branch (label exit)) (assign env (op get-global-environment)) (assign continue (label print-result)) (goto (label eval-dispatch)) print-result (perform (op print-stack-statistics)) (perform (op display) (const ";;; value: ")) (perform (op user-print) (reg val)) (perform (op newline)) (goto (label read-eval-print-loop)) unknown-expression-type (assign val (const unknown-expression-type-error)) (goto (label signal-error)) unknown-procedure-type (restore continue) (assign val (const unknown-procedure-type-error)) (goto (label signal-error)) signal-error (perform (op display) (reg val)) (perform (op newline)) (goto (label read-eval-print-loop)) eval-dispatch (test (op self-evaluating?) (reg exp)) (branch (label ev-self-eval)) (test (op variable?) (reg exp)) (branch (label ev-variable)) (test (op quoted?) (reg exp)) (branch (label ev-quoted)) (test (op quasiquote?) (reg exp)) (branch (label ev-quasiquote)) (test (op assignment?) (reg exp)) (branch (label ev-assignment)) (test (op definition?) (reg exp)) (branch (label ev-definition)) (test (op if?) (reg exp)) (branch (label ev-if)) (test (op lambda?) (reg exp)) (branch (label ev-lambda)) (test (op begin?) (reg exp)) (branch (label ev-begin)) (test (op let?) (reg exp)) (branch (label ev-let)) (test (op letrec?) (reg exp)) (branch (label ev-letrec)) (test (op cond?) (reg exp)) (branch (label ev-cond)) (test (op and?) (reg exp)) (branch (label ev-and)) (test (op or?) (reg exp)) (branch (label ev-or)) (test (op delay?) (reg exp)) (branch (label ev-delay)) (test (op application?) (reg exp)) (branch (label ev-application)) (goto (label unknown-expression-type)) ev-application (save continue) (save env) (assign unev (op operands) (reg exp)) (save unev) (assign exp (op operator) (reg exp)) (assign continue (label ev-appl-did-operator)) (goto (label eval-dispatch)) ev-appl-did-operator (restore unev) (restore env) (assign argl (op empty-arglist)) (assign proc (reg val)) (test (op no-operands?) (reg unev)) (branch (label apply-dispatch)) (save proc) ev-appl-operand-loop (save argl) (assign exp (op first-operand) (reg unev)) (test (op last-operand?) (reg unev)) (branch (label ev-appl-last-arg)) (save env) (save unev) (assign continue (label ev-appl-accumulate-arg)) (goto (label eval-dispatch)) ev-appl-accumulate-arg (restore unev) (restore env) (restore argl) (assign argl (op adjoin-arg) (reg val) (reg argl)) (assign unev (op rest-operands) (reg unev)) (goto (label ev-appl-operand-loop)) ev-appl-last-arg (assign continue (label ev-appl-accum-last-arg)) (goto (label eval-dispatch)) ev-appl-accum-last-arg (restore argl) (assign argl (op adjoin-arg) (reg val) (reg argl)) (restore proc) (goto (label apply-dispatch)) apply-dispatch (test (op primitive-procedure?) (reg proc)) (branch (label primitive-apply)) (test (op compound-procedure?) (reg proc)) (branch (label compound-apply)) (test (op compiled-procedure?) (reg proc)) (branch (label compiled-apply)) (test (op continuation?) (reg proc)) (branch (label continuation-apply)) (goto (label unknown-procedure-type)) primitive-apply (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) (restore continue) (goto (reg continue)) compound-apply (assign unev (op procedure-parameters) (reg proc)) (assign env (op procedure-environment) (reg proc)) (assign env (op extend-environment) (reg unev) (reg argl) (reg env)) (assign unev (op procedure-body) (reg proc)) (goto (label ev-sequence)) compiled-apply (restore continue) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) continuation-apply (assign val (op apply-continuation) (reg proc) (reg argl)) (restore continue) (goto (reg continue)) call-with-current-continuation (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (procedure)) (reg argl) (reg env)) (save continue) (assign unev (op make-continuation)) (assign proc (op lookup-variable-value) (const procedure) (reg env)) (assign argl (op list) (reg unev)) (goto (label apply-dispatch)) apply (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (proc args)) (reg argl) (reg env)) (save continue) (assign proc (op lookup-variable-value) (const proc) (reg env)) (assign argl (op lookup-variable-value) (const args) (reg env)) (goto (label apply-dispatch)) eval (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (expr envi)) (reg argl) (reg env)) (assign exp (op lookup-variable-value) (const expr) (reg env)) (assign env (op lookup-variable-value) (const envi) (reg env)) (goto (label eval-dispatch)) ev-delay (assign val (op delay-expression) (reg exp)) (assign exp (op list) (const lambda) (const ()) (reg val)) (assign val (reg exp)) (assign exp (op list) (const make-promise) (reg val)) (goto (label eval-dispatch)) load (save env) (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (filename)) (reg argl) (reg env)) (assign unev (op lookup-variable-value) (const filename) (reg env)) (assign unev (op open-input-file) (reg unev)) (perform (op push-input-port) (reg unev)) (restore env) load-1 (assign exp (op read) (reg unev)) (test (op eof-object?) (reg exp)) (branch (label load-3)) (save continue) (assign env (op get-global-environment)) (assign continue (label load-2)) (save unev) (goto (label eval-dispatch)) load-2 (restore unev) (restore continue) (goto (label load-1)) load-3 (perform (op pop-input-port)) (perform (op close-input-port) (reg unev)) (goto (reg continue)) ev-begin (assign unev (op begin-actions) (reg exp)) (save continue) (goto (label ev-sequence)) ev-sequence (assign exp (op first-exp) (reg unev)) (test (op last-exp?) (reg unev)) (branch (label ev-sequence-last-exp)) (save unev) (save env) (assign continue (label ev-sequence-continue)) (goto (label eval-dispatch)) ev-sequence-continue (restore env) (restore unev) (assign unev (op rest-exps) (reg unev)) (goto (label ev-sequence)) ev-sequence-last-exp (restore continue) (goto (label eval-dispatch)) ev-self-eval (assign val (reg exp)) (goto (reg continue)) ev-variable (assign val (op lookup-variable-value) (reg exp) (reg env)) (goto (reg continue)) ev-quoted (assign val (op text-of-quotation) (reg exp)) (goto (reg continue)) ev-lambda (assign unev (op lambda-parameters) (reg exp)) (assign exp (op lambda-body) (reg exp)) (assign val (op make-procedure) (reg unev) (reg exp) (reg env)) (goto (reg continue)) ev-quasiquote (assign exp (op rest-expressions) (reg exp)) (assign exp (op first-expression) (reg exp)) (assign level (const 0)) ev-qq (test (op null?) (reg exp)) (branch (label ev-qq-immediate)) (test (op symbol?) (reg exp)) (branch (label ev-qq-immediate)) (test (op quasiquote?) (reg exp)) (branch (label ev-qq-quasiquote)) (test (op unquote?) (reg exp)) (branch (label ev-qq-unquote)) (goto (label ev-qq-ordinary)) ev-qq-quasiquote (assign argl (op empty-arglist)) (assign val (op first-expression) (reg exp)) (assign argl (op adjoin-arg) (reg val) (reg argl)) (assign exp (op rest-expressions) (reg exp)) (assign exp (op first-expression) (reg exp)) (save argl) (save level) (assign level (op integer-plus) (reg level) (const 1)) (save continue) (assign continue (label ev-qq-quasiquote-1)) (goto (label ev-qq)) ev-qq-quasiquote-1 (restore continue) (restore level) (restore argl) (assign argl (op adjoin-arg) (reg val) (reg argl)) (assign val (reg argl)) (goto (reg continue)) ev-qq-unquote (test (op integer-equal) (reg level) (const 0)) (branch (label ev-qq-unquote-eval)) (assign argl (op empty-arglist)) (assign val (op first-expression) (reg exp)) (assign argl (op adjoin-arg) (reg val) (reg argl)) (assign exp (op rest-expressions) (reg exp)) (assign exp (op first-expression) (reg exp)) (save argl) (save level) (assign level (op integer-minus) (reg level) (const 1)) (save continue) (assign continue (label ev-qq-unquote-1)) (goto (label ev-qq)) ev-qq-unquote-1 (restore continue) (restore level) (restore argl) (assign argl (op adjoin-arg) (reg val) (reg argl)) (assign val (reg argl)) (goto (reg continue)) ev-qq-unquote-eval (assign exp (op rest-expressions) (reg exp)) (assign exp (op first-expression) (reg exp)) (save continue) (assign continue (label ev-qq-unquote-eval-1)) (goto (label eval-dispatch)) ev-qq-unquote-eval-1 (restore continue) (goto (reg continue)) ev-qq-ordinary (assign unev (reg exp)) (assign argl (op empty-arglist)) (save continue) ev-qq-loop (assign exp (op first-expression) (reg unev)) (save unev) (save argl) (assign continue (label ev-qq-accumulate)) (goto (label ev-qq)) ev-qq-accumulate (restore argl) (assign argl (op adjoin-arg) (reg val) (reg argl)) (restore unev) (assign unev (op rest-expressions) (reg unev)) (test (op no-expressions?) (reg unev)) (branch (label ev-qq-return)) (goto (label ev-qq-loop)) ev-qq-return (assign val (reg argl)) (restore continue) (goto (reg continue)) ev-qq-immediate (assign val (reg exp)) (goto (reg continue)) ev-let (assign exp (op let->combination) (reg exp)) (goto (label eval-dispatch)) ev-letrec (assign exp (op letrec->let) (reg exp)) (goto (label eval-dispatch)) ev-cond (assign exp (op cond->if) (reg exp)) (goto (label eval-dispatch)) ev-and (save continue) (assign unev (op and-expressions) (reg exp)) (test (op no-expressions?) (reg unev)) (branch (label ev-and-no-expresions)) ev-and-loop (assign exp (op first-expression) (reg unev)) (assign continue (label ev-and-exp-evaluated)) (save unev) (save env) (goto (label eval-dispatch)) ev-and-exp-evaluated (restore env) (restore unev) (test (op true?) (reg val)) (branch (label ev-and-true-detected)) (goto (label ev-and-return)) ev-and-true-detected (assign unev (op rest-expressions) (reg unev)) (test (op no-expressions?) (reg unev)) (branch (label ev-and-return)) (goto (label ev-and-loop)) ev-and-no-expresions (assign exp (const true)) (assign val (op lookup-variable-value) (reg exp) (reg env)) ev-and-return (restore continue) (goto (reg continue)) ev-or (save continue) (assign unev (op or-expressions) (reg exp)) (test (op no-expressions?) (reg unev)) (branch (label ev-or-no-expresions)) ev-or-loop (assign exp (op first-expression) (reg unev)) (assign continue (label ev-or-exp-evaluated)) (save unev) (save env) (goto (label eval-dispatch)) ev-or-exp-evaluated (restore env) (restore unev) (test (op true?) (reg val)) (branch (label ev-or-return)) (assign unev (op rest-expressions) (reg unev)) (test (op no-expressions?) (reg unev)) (branch (label ev-or-return)) (goto (label ev-or-loop)) ev-or-no-expresions (assign exp (const false)) (assign val (op lookup-variable-value) (reg exp) (reg env)) ev-or-return (restore continue) (goto (reg continue)) ev-if (save exp) (save env) (save continue) (assign continue (label ev-if-decide)) (assign exp (op if-predicate) (reg exp)) (goto (label eval-dispatch)) ev-if-decide (restore continue) (restore env) (restore exp) (test (op true?) (reg val)) (branch (label ev-if-consequent)) ev-if-alternative (assign exp (op if-alternative) (reg exp)) (goto (label eval-dispatch)) ev-if-consequent (assign exp (op if-consequent) (reg exp)) (goto (label eval-dispatch)) ev-assignment (assign unev (op assignment-variable) (reg exp)) (save unev) (assign exp (op assignment-value) (reg exp)) (save env) (save continue) (assign continue (label ev-assignment-1)) (goto (label eval-dispatch)) ev-assignment-1 (restore continue) (restore env) (restore unev) (perform (op set-variable-value!) (reg unev) (reg val) (reg env)) (assign val (const ok)) (goto (reg continue)) ev-definition (assign unev (op definition-variable) (reg exp)) (save unev) (assign exp (op definition-value) (reg exp)) (save env) (save continue) (assign continue (label ev-definition-1)) (goto (label eval-dispatch)) ev-definition-1 (restore continue) (restore env) (restore unev) (perform (op define-variable!) (reg unev) (reg val) (reg env)) (assign val (const ok)) (goto (reg continue)) exit (perform (op exit)) end-of-interpreter))(() () ((goto (label read-eval-print-loop))))