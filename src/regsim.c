#include <stdio.h>
#include <stdlib.h>

#include "common.h"
#include "parameters.h"

#include "primitive.h"
#include "null.h"
#include "symbol.h"
#include "number.h"
#include "sstring.h"
#include "boolean.h"
#include "port.h"

#include "argcheck.h"
#include "insts.h"
#include "regsim.h"

#include "eprint.h"
#include "util.h"
#include "rsscan.h"
#include "rsparse.h"
#include "scscan.h"
#include "scparse.h"

#include "memory.h"


enum {NVINIT = 1, NVGROW = 2};

struct instseq {
    int  nval;    /* current number of values */
    int  max;     /* allocated number of values */
    Inst *insts;  /* array of Insts */
};

struct regsim {
    unsigned int pc;      /* program counter */
    bool         flag;    /* flag used by test and branch insts */
    InstSeq      insts;   /* the instruction sequence */
    Hashtable    labels;  /* the labels */
    Hashtable    prims;   /* primitives */
};


static Register regInitialize;

RegSim* theRegSim;

int rsAddInst(Inst newInst)
{
    Inst* nvp;

    if (theRegSim->insts.insts == NULL) { /* first time */
	theRegSim->insts.insts = (Inst*)emalloc(NVINIT * sizeof(Inst));
	theRegSim->insts.max = NVINIT;
	theRegSim->insts.nval = 0;
    } else if (theRegSim->insts.nval >= theRegSim->insts.max) { /* grow */
	nvp = (Inst*)realloc(theRegSim->insts.insts,
			     (NVGROW*theRegSim->insts.max)*sizeof(Inst));
	if (nvp == NULL) {
	    eprintf("rsAddInst: cannot realloc\n");
	    return -1;
	}
	theRegSim->insts.max *= NVGROW;
	theRegSim->insts.insts = nvp;
    }
    theRegSim->insts.insts[theRegSim->insts.nval] = newInst;
    return theRegSim->insts.nval++;
}

void rsAddLabel(char* label)
{
    /* insts.nval points to the next free position in
     * the instruction sequece, i.e. to the position where
     * the next instruction is to be stored, i.e. to the
     * location this label points to.
     */
    
    Binding b = htLookup(theRegSim->labels, label, HASHOP_LOOKUP,
			 (void*)theRegSim->insts.nval);
    if (b != NULL)
      eprintf("multiply defined label: %s\n", label);
    htLookup(theRegSim->labels, label, HASHOP_CREATE, (void*)theRegSim->insts.nval);
}

unsigned int rsLookupLabel(char* labelName)
{
    Binding b = htLookup(theRegSim->labels, labelName, HASHOP_LOOKUP, 0);
    if (b == NULL)
      eprintf("label not found: %s\n", labelName);
    return (unsigned int)bindGetValue(b);
}

void rsAddPrimitive(char* primName, Primitive prim)
{
    Binding b = htLookup(theRegSim->prims, primName, HASHOP_LOOKUP, (void*)prim);
    if (b != NULL)
      eprintf("multiply defined primitive: %s\n", primName);
    htLookup(theRegSim->prims, primName, HASHOP_CREATE, (void*)prim);
}

Primitive rsLookupPrimitive(char* primName)
{
    Binding b = htLookup(theRegSim->prims, primName, HASHOP_LOOKUP, 0);
    if (b == NULL)
      eprintf("primitive not found: %s\n", primName);
    return (Primitive)bindGetValue(b);
}

void rsPrintInstSeq(void)
{
    unsigned int i;
    printf("; This file is generated by the pretty printer\n");
    printf("; The needs- and modifies-registers are discarded\n");
    printf("(()()\n(\n");
    for (i = 0; i < theRegSim->insts.nval; i++) {
	insPrint(theRegSim->insts.insts[i]);
	printf("\n");
    }
    printf("))\n");
#if 0
    printf("Labels:\n");
    htPrint(theRegSim->labels);
#endif
}

void rsStart(void)
{
    theRegSim->pc = 0;
}

void rsAdvancePc(void)
{
    theRegSim->pc++;
}

void rsSetPc(unsigned int index)
{
    theRegSim->pc = index;
}

unsigned int rsGetPc(void)
{
    return theRegSim->pc;
}

bool isFlagSet(void)
{
    return theRegSim->flag;
}

static void execRegisterExp(Register result, RegisterExp reg)
{
    regCopy(result, rexGetReg(reg));
}

#if 0
static void execConstList(Register result, List list)
{
    Register regResult2 = regGetTemp();
    void* value;

    ListIterator li;
    regMakeNull(result);
    for (li = lstGetIteratorTail(list); !liIsNull(li); liPrev(li)) {
	liGetValue(li, &value);
	regMakeSymbol(regResult2, (char*)value);
	cons(result, regResult2, result);
    }
    liDelete(li);
    regFreeTemp(regResult2);
}
#endif

static void readString(Register result, char* string)
{
    void* prevBuffer = scGetCurrentYYBuffer();
    void* currentBuffer = scScanString(string);
    scparse();
    regCopy(result, regSimple);
    scDeleteYYBuffer(currentBuffer);
    scSetCurrentYYBuffer(prevBuffer);
}

static void execConstant(Register result, Constant con)
{
    readString(result, conGetString(con));
}

static void execLabel(Register target, Label label)
{
    regMakeNumber(target, lblGetIndex(label));
}

static void execInput(Register result, Input input)
{
    switch (inpGetType(input)) {
    case INPUT_REG:
	execRegisterExp(result, inpGetReg(input));
	break;
    case INPUT_CONST:
	execConstant(result, inpGetConst(input));
	break;
    case INPUT_LABEL:
	execLabel(result, inpGetLabel(input));
	break;
    default:
	printf("execInput: unknown input type\n");
	break;
    }
}

static void evalOperands(Register result, List list)
{
    Register regResult = regGetTemp();
    void* value;

    ListIterator li;
    regMakeNull(result);
    /* Walk the list from tail to head so we can use cons to build the result */
    for (li = lstGetIteratorTail(list); !liIsNull(li); liPrev(li)) {
	liGetValue(li, &value);
	execInput(regResult, (Input)value);
	cons(result, regResult, result);
    }
    liDelete(li);
    regFreeTemp(regResult);
}

static void execOperationExp(Register result, OperationExp op)
{
    Register regArguments = regGetTemp();

    Primitive primitive = opGetPrimitive(op);
    evalOperands(regArguments, opGetInputs(op));
    (*primitive)(result, regArguments);

    regFreeTemp(regArguments);
}

static void execAssign(Inst inst)
{
    Source src = insGetAssignSource(inst);
    Register target = rexGetReg(insGetAssignTarget(inst));
    switch (srcGetType(src)) {
    case SRC_REG:
	regCopy(target, rexGetReg(srcGetReg(src)));
	break;
    case SRC_CONST:
	execConstant(target, srcGetConst(src));
	break;
    case SRC_OP:
	execOperationExp(target, srcGetOp(src));
	break;
    case SRC_LABEL:
	execLabel(target, srcGetLabel(src));
	break;
    }
    rsAdvancePc();
}

static void execTest(Inst inst)
{
    Register regResult = regGetTemp();

    execOperationExp(regResult, insGetTest(inst));
    theRegSim->flag = regGetBoolean(regResult);
    rsAdvancePc();

    regFreeTemp(regResult);
}

static void execPerform(Inst inst)
{
    Register regResult = regGetTemp();

    execOperationExp(regResult, insGetPerform(inst));
    rsAdvancePc();

    regFreeTemp(regResult);
}

void execJump(Target trg)
{
    Label label;
    RegisterExp regExp;

    switch (trgGetType(trg)) {
    case TRG_REG:
	regExp = trgGetReg(trg);
	rsSetPc(regGetNumber(rexGetReg(regExp)));
	break;
    case TRG_LABEL:
	label = trgGetLabel(trg);
	rsSetPc(lblGetIndex(label));
	break;
    }
}

static void execSave(Inst inst)
{
    RegisterExp regExp = insGetSave(inst);
    char* name = rexGetName(regExp);
    Register reg = rexGetReg(regExp);
#ifdef STACK_GUARDED
    save2(name, reg);
#else
    save(reg);
#endif
    rsAdvancePc();
}

static void execRestore(Inst inst)
{
    RegisterExp regExp = insGetRestore(inst);
    char* name = rexGetName(regExp);
    Register reg = rexGetReg(regExp);
#ifdef STACK_GUARDED
    restore2(name, reg);
#else
    restore(reg);
#endif
    rsAdvancePc();
}

void executeInst(Inst inst)
{
#if 0
    Register exp;
    regLookup("exp", &exp);
    insDump(inst);
    regPrint(exp);
    printf("\n");
#ifdef STACK_GUARDED
#if 0
    printStack();
#endif
#endif
#endif
    switch (insGetType(inst)) {
    case INST_ASSIGN:
	execAssign(inst);
	break;
    case INST_PERFORM:
	execPerform(inst);
	break;
    case INST_TEST:
	execTest(inst);
	break;
    case INST_LABEL:
    case INST_COMMENT:
	rsAdvancePc();
	break;
    case INST_BRANCH:
	if (isFlagSet())
	    execJump(insGetBranch(inst));
	else
	    rsAdvancePc();
	break;
    case INST_GOTO:
	execJump(insGetGoto(inst));
	break;
    case INST_SAVE:
	execSave(inst);
	break;
    case INST_RESTORE:
	execRestore(inst);
	break;
    default:
	printf("Unknown instruction type\n");
	break;
    }
}

void debugger(Inst inst)
{
    char c;
    char regName[32];
    Register reg;

    insDump(inst);
    while (1) {
	switch (c = getchar()) {
	case 'n':
	    getchar();
	    return;
	case 'p':
	    scanf("%s", regName);
	    if (!regLookup(regName, &reg))
		printf("reg %s not defined\n", regName);
	    else
		regDisplayToCurrentPort(reg);
	    getchar();
	    break;
	default:
	    return;
	}
    }
}

static bool regsimContinue = TRUE;

void exit_if(Register result, Register operands)
{
    checkArgsEQ("exit", "", operands);
    regsimContinue = FALSE;
}

void rsExecInstSeq(void)
{
    int retval;
    Inst inst;

    rsStart();
    regMakeNumber(regInitialize, 1);

    while (TRUE) {
	if ((retval = setjmp(jumpBuffer)) == 0) {
	    while ((theRegSim->pc >= 0) &&
		   (theRegSim->pc < theRegSim->insts.nval) &&
		   regsimContinue) {
		inst = theRegSim->insts.insts[theRegSim->pc];
		executeInst(inst);
	    }
	    break;
	} else {
	    printf("*** Reset\n");
	    rsStart();
	    /* we do not want to do the initialization anymore, jump around it */
	    regMakeNumber(regInitialize, 0);
	}
    }
}


/**************************************************/

static void expandRegisterExp(RegisterExp regExp)
{
    Register reg;
    char* regName = rexGetName(regExp);
    if (!regLookup(regName, &reg)) {
	printf("Allocating register %s\n", regName);
	reg = regAllocate(regName);
    }
    rexSetReg(regExp, reg);
}

static void expandLabel(Label lbl)
{
    lblSetIndex(lbl, rsLookupLabel(lblGetName(lbl)));
}

static void expandInput(Input input)
{
    switch (inpGetType(input)) {
    case INPUT_REG:
	expandRegisterExp(inpGetReg(input));
	break;
    case INPUT_CONST:
	break;
    case INPUT_LABEL:
	expandLabel(inpGetLabel(input));
	break;
    }
}

static void expandInputs(List list)
{
    ListIterator li;
    void* value;

    for (li = lstGetIteratorHead(list); !liIsNull(li); liNext(li)) {
	liGetValue(li, &value);
	expandInput((Input)value);
    }
    liDelete(li);
}

static void expandOperationExp(OperationExp op)
{
    expandInputs(opGetInputs(op));
    opSetPrimitive(op, rsLookupPrimitive(opGetName(op)));
}

static void expandSource(Source src)
{
    switch (srcGetType(src)) {
    case SRC_REG:
	expandRegisterExp(srcGetReg(src));
	break;
    case SRC_CONST:
	break;
    case SRC_OP:
	expandOperationExp(srcGetOp(src));
	break;
    case SRC_LABEL:
	expandLabel(srcGetLabel(src));
	break;
    }
}

static void expandTarget(Target target)
{
    switch (trgGetType(target)) {
    case TRG_REG:
	expandRegisterExp(trgGetReg(target));
	break;
    case TRG_LABEL:
	expandLabel(trgGetLabel(target));
	break;
    }
}

/* expandInst: look up the labels, registers and operations
 * referenced by name in the instruction and store 
 * a pointer to the actual object in the instruction
 */
static void expandInst(Inst inst)
{
    switch (insGetType(inst)) {
    case INST_ASSIGN:
	expandRegisterExp(insGetAssignTarget(inst));
	expandSource(insGetAssignSource(inst));
	break;
    case INST_PERFORM:
	expandOperationExp(insGetPerform(inst));
	break;
    case INST_TEST:
	expandOperationExp(insGetTest(inst));
	break;
    case INST_LABEL:
	break;
    case INST_BRANCH:
	expandTarget(insGetBranch(inst));
	break;
    case INST_GOTO:
	expandTarget(insGetGoto(inst));
	break;
    case INST_SAVE:
	expandRegisterExp(insGetSave(inst));
	break;
    case INST_RESTORE:
	expandRegisterExp(insGetRestore(inst));
	break;
    case INST_COMMENT:
        break;
    default:
	printf("expandInst: Unknown instruction type\n");
	break;
    }
}

void rsExpandInstSeq(void)
{
    unsigned int i;
    for (i = 0; i < theRegSim->insts.nval; i++)
	expandInst(theRegSim->insts.insts[i]);
}

/**************************************************/

void rsReadInstSeq(char* fileName)
{
    extern char* rsFileName; /* defined in rcparse.y */
    extern unsigned int rsLineNumber; /* defined in rsscan.l */

    if ((rsin = fopen(fileName, "r" )) == NULL) {
	eprintf("Cannot open file %s\n", fileName);
    }
    rsFileName = fileName;
    rsLineNumber = 1;
    rsparse(); 
    fclose(rsin);
#if 0
    rsDeleteYYBuffer(rsGetCurrentYYBuffer());
    rsin = stdin;
#endif
}

void makeRegSim(void)
{
    theRegSim = (RegSim*)emalloc(sizeof(RegSim));
    theRegSim->pc = 0;
    theRegSim->flag = 0;
    theRegSim->prims = htCreate();
    theRegSim->labels = htCreate();
    theRegSim->insts.insts = NULL;

    regInitialize = regAllocate("init");
}

void deleteRegSim(void)
{
    unsigned int i;
    for (i = 0; i < theRegSim->insts.nval; i++)
	insDelete(theRegSim->insts.insts[i]);
    free(theRegSim->insts.insts);

    htDelete(theRegSim->prims);
    htDelete(theRegSim->labels);
    free(theRegSim);
}

