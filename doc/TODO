t looks like there is a problem when calling a compound procedure
with internal define from a compiled procedure.
For example running a compiled fib-procedure using non-compiled
initialization files produces wrong results, but using compiled
initialization files works ok.
For example, run
./sci fib.rms -> wrong result, compiled from fib.scm
./sci fib2.rms -> works ok, compiled from fib2.scm


There is lots of looping through the data structures with
potentially infinite loops. To avoid being stuck in these loops
(Display, Copy, Relocate) use some looping identifier, as in
Relocate.

Simplify the register allocation interface.

Make the Scheme list the internal representation of regsim programs.
This implies that we could discard the regsim parser altogether.
The rationale is that the compiler produces the regsim programs in
Scheme list and we would like to be able to execute the program right away
after the compilation without the need to store the program in a file
and read it back with the regsim parser.
UPDATE: Implemented this and noted it is not a good idea.
The implementation is very awkward and slow, the old implementation
is more C-like and very fast compred to this.


Implement more numbers.

Implement hygienic macros. Check out the pluggable implemention
(www.schemers.org)

Make the core files (list, hash, ...) into a static (?) library and
use that library instead of linking the object files directly into the
executable.

Fix all the TODOs in the source code.

The number of registers (both static and dynamic) is fixed 200/100,
do something!

Save (and restore) the scheme scanner linenumber in the input port stack.

Force and delay

Constant objects (literals are constants)
(vectotr-set! #(1 2 3) 0 'foo) should produce and error because
the vector is literal and thus constant. Add a flag to the objects
telling whether it is constant. Update: mit-scheme does not work
this way!

Is there a way to make objects take less space? Use pointers to objects?

Implement continuations.
Initial implementation done 1.7.2002.

--------------------------------------------------

Lots of references to objects are held. For example,
referring to a variable pointing to a vector increases the
vector's refcount. Where are these references kept? 
Garbage collection does not unref the vector, but exiting the
interpreter does.
The register machine simulator leaves copies of objects in
memory when it evaluates the operator arguments. These copies
do not matter, they are unreferred when the memory is used
(written). The unreferring can be hastened by clearing the
memory after garbage collection.

All the register allocation could be made with the dynamic
registers?

Something is wrong with the vector implementation. Sometimes
gc messes up the memory when vectors are involved.
This is due to vector aliasing. There is multiple pointers to the
vector, made sure the vector is garbage-collected only once
per gc round.

When (if) vectors work ok, it might be reasonable to allocate
registers from a predefined vector.



How to compile the compiler
---------------------------

The compiler uses constructs it cannot currently handle
(i.e. the compiler cannot compile itself):

o let-special forms (let is compiled into a variable lookup)
o quasiquote (used in the compiler)
o compound procedures from "r5rs.scm" (e.g. map is compiled into
  variable lookup, but is tested if it is a compiled procedure or
  primitive; it is neither)
o dot-notation of procedure arguments (in r5rs.scm)

let should be easy to handle by adding the let->combination to
the compiler.

quasiquote is harder. The right thing to do would be modifying the
compiler so that it handles quasiquotes. A workaround would be to
modify the compiler so that it does not use quasiquotes. This should
be easy.

Compound procedures: should we compile the r5rs.scm too? So the
procedures defined there (e.g. map) could be used. Do we need
to be able to load multiple rms-files into the simulator? If yes
is there a possibility to name clashes (esp. the label names)?
The book talks about the possibility to mix calls to compiled and
compound procedures. This might be one solution. Investigate this.



More modular structure
----------------------
Is it possible to make the register machine simulator
a separate program so that compiled programs could be run
using only the relevant portions if it? The Scheme
interpreter would use it as a part of itself.

We would like to have
o A register machine simulator. Register machine programs
  could be passed to this for execution (for example, the
  programs generated by the scheme compiler). How do we specify
  run-time support required by the regsim programs?
o A Scheme interpreter. This would be the "repl.scm" loaded
  into the register machine simulator plus lots of support code.
o A Scheme compiler. This would be the Scheme interpreter loaded
  with the ch5-compiler.scm.

The runtime support code should:
	1 Allocate the registers
	2 Install the primitives
needed by the regsim program.

For example, the regsim program fib.reg could be run like this:

	regsim -f fib.reg -o math.o

i.e. the file containing the regsim program (fib.reg), and
the support code (math.o) are given as a command-line parameter.
The scheme interpreter would be more complex:

	regsim -f repl.reg -o syntax.o -o env.o -o support.o
               -if init.scm

Here the -if would be a flag to the scheme interpreter, not
to the regsim, telling it to load the file "init.scm" at
startup.
The runtime support modules are loaded dynamically and
each module must have an interface to initialize itself.

It might be easier to implement the scheme interpreter
as it is done so far. That is make a regsim library and
use it as part of the interpreter.

14.5.2002: Current opinion:
regsim is an executable, option -l (or something) tells the
name of the dynamic library to load ("lib.so"). The lib is
loaded using dlopen. This lib should
have a predetermined interface function ("init" or something)
to initialize the dynamic lib. It is called by the regsim.

	regsim -l scheme_interpreter.so -f ch5-compiler.scm

regsim would pass all uninterpreted options (here -f) to the
initialization function. The initialization function should:
o tell the regsim to load a file containing the regsim program
o allocate the needed registers
o install the required primitives to the regsim (should the primitives
  defined in the modules of regsim (e.g. memory.c) be installed
  automatically, or by the user module?)
o initialize itself
o start running the actual program or tell the regsim to start
  running from the beginning of the loaded regsim program

If we have a simple register machine simulator program that
does not define any primitives of its own (e.g. fib), it
might be nice if we could run it just by telling the regsim
the name of the file (fib.reg) to load. Registers to allocate
may be defined with options (here -r).

	regsim -file fib.reg -reg n -reg val -reg continue


The memory.c module is big, it should be split into smaller pieces.
o basic memory services
  (cons, car, cdr, set-car!, set-cdr!, initMemory, gc)
o stack services (save, restore)
o object creation, classifying, dumping, makeXXX, isXXX
o register allocation, deallocation
o math stuff
14.5.2002: Not quite sure if this is true.

env.c and support.c could be written as regsim programs.

eval and apply could be made "compiled-procedure".

Directory structure:

	scm/
		init.scm	Initial Scheme definitions
		compiler.scm	Scheme compiler
		interpret.scm	Scheme interpreter
	reg/
		interpret.reg	Hand-written Scheme interpreter
				Compiled Scheme interpreter
		compiler.reg	Compiled Scheme compiler
	regsim/
	lib/
	bin/


Interpreter general structure
-----------------------------
Rethink the eval and apply -primitives. The key consideration
is to make the register machine program "re-entrant", i.e.
such that it can call itself recursively.

Rethink also the load-primitive. In principle the
read-eval-print-loop could be implemented as a load
from stdin with printing of the values. It might be
possible to have multiple recursive repls in progress
(as in mit-scheme).

Should everything implemented in the register machine program
(repl.scm) be available as a primitive (as apply and eval are)?
That is, should we enter the register machine only via these
C-functions: apply, eval, load (repl would be implemented as
a special kind of load that reads expressions from stdin).
Do we need the regsim for anything else but to implement
proper tail recursion and special forms?

14.5.2002: This idea is probably close to the idea of
compiled-procedures. That the regsim code emitted by the
compiler uses.


Resource management
-------------------
When objects of type symbol, string, primitive and
port are garbage-collected, should the data they point
to be free'd? If yes, how can this be done. Should we use
some kind of reference counting on symbols? (Idea:
symbols only use the "name"-field of "Binding", store
the reference count (as an int) to the "value"-field.)

The cons-primitive could be made responsible for freeing
data that is no more referenced. Every time a new pair
is about to be allocated, cons first checks if the old
contents of theCars and theCdrs should be free'd. This
should be easy for interned symbols, but consider the
following:

	(define a "Foo")
	(define b a)
	(define c "Foo")

Here a and b refer to the same string (so that if the string
is changed with e.g. string-set!, the change is reflected in
both a and b). However, the change is not reflected in c. So
the first "Foo" has two variables referring to it, whereas the
second has only one. A string should only be free'd when it
is not referred by anyone (variable). How do we keep track of
this?

                +------+
a-------------->|object|---------->"Foo"
b-------------->+------+            ^
                                    |
                +------+            |
c-------------->|object|------------+
                +------+


Bindings should maintain a reference count.
Copy on write (string-set!) if refcount > 1.
Increase refcount on
	o relocate (GC)
	o creating strings.
Decrease refcount in cons when using memory.
	o Binding is deleted if refcount becomes zero.

When writing into memory, the reference counts of both old
and new contents must be updated.

06032002: Strings are now implemented with no interning.
So there is no need for copy-on-write. The above example
on string-set! works as expected.


Input port memory
-----------------
14.5.2002: Memory for the input port structure is allocatedin makeInputPort_,
but is it free'd somewhere? Should it be free'd in deleteObject

Register usage
--------------
The register machine simulator register usage is messy.
Clean things up.


Continuations
-------------
Implement continuations.


Introspection
-------------
Make procedures that can be used to ask about primitives.
For example:
(arguments cons) => (* *)
(arguments car) => (p)
(arity cons) => 2
(arity car) => 1
(help cons) => "construct a new pair with a and b as objects"
(help car) => "return the car object of a pair"

The name (string) of a primitive is stored twice.
Once in the function definePrimitive

	definePrimitive("cons", cons_if);

and again in the _if -interface function as an argument
to the checkArgsEQ-function

	checkArgsEQ("cons", "**", operands);

Can these be combined into one. Perhaps into a
"Primitive"-object that contains the following information:
o display name ("cons")
o argument specification ("* *")
o help text ("construct a new pair with a and b as objects")
o the (pointer to) actual function
o something else?
This could be used to implement the introspection too.

That is, definePrimitive would be a constructor for a
primitive object, it might be called like this:
definePrimitive("null-environment", "n", nullEnvironment_if);

It might be possible to get rid of the interface procedures
(_if), if the arguments checking could be moved to
execOperationExp (regsim.c) and applyPrimitiveProcedure
(memory.c).

14.5.2002: Keep in mind, however, that the interface procedure
also expands the arguments from a list to individual args. So
the above idea might not be as good.


Debugger
--------
o breakpoints
o stepping (next, in to proc, out from proc)
o register and variable examination

Numbers
-------
The interpreter currently handles only integer numbers.
Make it proficient with other numbers (rational, real, complex)

Negative numbers are not recognized.
11032002: Negative integer numbers are now recognized.


Misc
----
o Interpreter crashes if the file specified in the command line
  (with the -f -switch) is not found. openInputFile ends up
  calling longjmp with setjmp not called in advance. Fix:
  call setjmp in "loadFiles".

o There is something wrong with the "load". When you
  try to load a file, (using (load "file.scm")) the
  interpreter says it cannot open the file. When you
  try it again, it works.

o Constant objects (created by literal expressions, the parser).

o Compile the environment, syntax, and support procedures
  for the register machine simulator.

o Lazy evaluation (delay, force).

o Decent error handling.

o Better error messages for the parser.

o Failure to recycle memory should not exit the program,
  it should only abort the current computation.

o Update everything to R5RS (quite a lot additions)

o let*, letrec, named let

error
eprintf should not exit the program

o memq, memv, member
o assq, assv, assoc
o eq?,  eqv?, equal?
o <=, >=
o zero?, positive?, negative?
o file and port operations

o When does current-input-port and current-output-port change
  their values?

o scparser.y crashes sometimes when you try to load the
  same file twice.

o Make accumulate, map, filter to accept multiple sequences.


===========================================================

These are already done
----------------------

Add a conditional jump to the beginning of the interpreter.rms
to control jump around initialization. DONE.

Create a test suite for the interpreter.
Skeleton test suite is done. It needs much more test cases.

Add command-line switch to
o Specify the amount of memory to reserve at startup.
o Specify the register machine simulator program file
  to be loaded end executed.
o Inhibit the loading of the init.scm file.

Test the tail-recursiveness by instrumenting the stack to
see its maximim depth.
7.2.2002: Done, seems to do the tail-recursion correctly.

Loading the ch5-compiler.scm and running it on some
non-trivial input (e.g.
(compile
 '(define (fib n)
    (if (< n 2)
	n
        (+ (fib (- n 2)) (fib (- n 1)))))
 'val 'next)
) exposes problems (lots of gc and
"*** Too many arguments supplied" from extendEnvironment.)
Is there still some register trashing?
6.2.2002: No register trashing, it just required a version
of "append" that accepts more than two arguments.

An error (e.g. unboud variable) should abort the evaluation
of current expression and return to the top level repl.
(instead of happily returning false, which is a legitimate
variable value.)
6.2.2002: This is now the case. Used setjmp/longjmp for this.

list? (list is terminated with null and has finite length).
(See page 260, exercise 3.19 on SICP, 2nd edition).
5.2.2002: Done, used the "hare and tortoise" algorithm.

Should we pre-define symbol "nil" to () (as "true" and
"false" are predefined to TRUE and FALSE respectively)?
5.2.2002: done

Strings are currently interned, should they be not?
If you modify a string (string-set!) shouldn't it affect
only the string in question? Also string-copy should return
a new string that does not share memory with the original.
4.2.2002: Changed strings to non-interned.

How can we make "apply" a procedure (implemented as a primitive)
instead of syntax (implemented in the interpreter)?
31.1.2002 Done.

Conversions:
o symbol->string (DONE 1.2.2002)
o string->symbol (DONE 1.2.2002)
o number->string (DONE 1.2.2002)
o string->number (DONE 1.2.2002)
o string-append  (DONE 1.2.2002)

Change the object type to contain pointers to primitives,
ports, etc. This way more information can be stored
without increasing the size of the object type. This
is convenient when printing the objects so e.g. the name of
the object can be printed (primitive name, file correspoding
to a port, etc.) (DONE 31.1.2002)

add "#ifdef DEBUG" -directives around the type checkers
in memory.c (DONE 31.1.2002). Update 20.02.2002: changed
this to use the assert-statements instead.

Parser recognizes the quote ('), quasiquote (`), unquote (,),
and unquote-splicing (,@) -constructs but only quote is
implemented in the interpreter. Implement the others too.
4.2.2002: quasiquote and unquote are implemented,
unquote-splicing is not (yet).

make parser recognize () (should evaluate to ())
4.2.2002: done, parser already recognized it, the trick
was to make it self-evaluating.


